{"meta":{"title":"CALVIN","subtitle":null,"description":"一个有趣的灵魂","author":"CALVIN","url":"/https://calvinstudio.github.io"},"pages":[{"title":"about","date":"2019-11-11T14:14:36.000Z","updated":"2019-11-12T02:29:01.963Z","comments":false,"path":"about/index.html","permalink":"/https://calvinstudio.github.io/about/index.html","excerpt":"","text":"[CALVIN] 与&nbsp; calvin&nbsp; （ ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-10-15T00:10:32.000Z","comments":false,"path":"bangumi/index.html","permalink":"/https://calvinstudio.github.io/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"Categories","date":"2019-11-06T07:35:24.000Z","updated":"2019-11-06T07:50:00.619Z","comments":true,"path":"categories/index.html","permalink":"/https://calvinstudio.github.io/categories/index.html","excerpt":"","text":""},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-10-15T00:10:32.000Z","comments":false,"path":"client/index.html","permalink":"/https://calvinstudio.github.io/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-10-15T00:10:32.000Z","comments":true,"path":"comment/index.html","permalink":"/https://calvinstudio.github.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-10-15T00:10:32.000Z","comments":false,"path":"donate/index.html","permalink":"/https://calvinstudio.github.io/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"欢迎留言","date":"2019-11-06T14:05:40.481Z","updated":"2019-11-06T14:05:40.481Z","comments":true,"path":"guestbook/index.html","permalink":"/https://calvinstudio.github.io/guestbook/index.html","excerpt":"","text":""},{"title":"Link","date":"2018-06-07T14:17:49.000Z","updated":"2019-11-06T12:36:35.298Z","comments":true,"path":"link/index.html","permalink":"/https://calvinstudio.github.io/link/index.html","excerpt":"","text":""},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-10-15T00:10:32.000Z","comments":false,"path":"lab/index.html","permalink":"/https://calvinstudio.github.io/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-12-25T06:09:47.735Z","comments":false,"path":"music/index.html","permalink":"/https://calvinstudio.github.io/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-10-15T00:10:32.000Z","comments":true,"path":"links/index.html","permalink":"/https://calvinstudio.github.io/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-10-15T00:10:32.000Z","comments":true,"path":"rss/index.html","permalink":"/https://calvinstudio.github.io/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-11-12T08:03:56.117Z","comments":true,"path":"tags/index.html","permalink":"/https://calvinstudio.github.io/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-10-15T00:10:32.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/https://calvinstudio.github.io/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"GITEE PAGES","date":"2018-12-20T15:14:28.000Z","updated":"2020-01-25T13:36:25.271Z","comments":false,"path":"web/index.html","permalink":"/https://calvinstudio.github.io/web/index.html","excerpt":"","text":"GITEE PAGES CODING PAGES","keywords":"点击进入"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-31T14:07:57.759Z","comments":false,"path":"video/index.html","permalink":"/https://calvinstudio.github.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"多CPU线程多GPU并行","slug":"OpenMPGPU","date":"2020-02-07T16:00:00.000Z","updated":"2020-02-08T10:21:22.810Z","comments":true,"path":"2020/02/08/OpenMPGPU/","link":"","permalink":"/https://calvinstudio.github.io/2020/02/08/OpenMPGPU/","excerpt":"","text":"多CPU线程多GPU并行原理 1：首先利用openmp实现Cpu多线程并行 2：然后将每个CPU线程各去唤醒一个GPU 3：每个CPU线程分配给对应的GPU相同或不同类型的任务 代码#include &quot;cuda_runtime.h&quot; #include &quot;device_launch_parameters.h&quot; #include &lt;stdio.h&gt; #include &lt;omp.h&gt; #include &lt;unistd.h&gt; __global__ void helloFromGPU(int i) { for (int k = 0; k &lt; 10; k++) printf(&quot;Hello World from GPU%d!\\n&quot;, i); } int main(void) { // hello from cpu const int cputhread = 15; omp_set_num_threads(cputhread); // set threads int threadsnum = omp_get_num_threads(); #pragma omp parallel { #pragma omp for for (int i = 0; i &lt; 4; i++) { cudaSetDevice(i); printf(&quot;Hello World from CPU%d!\\n&quot;, i); helloFromGPU&lt;&lt;&lt;1, 10&gt;&gt;&gt;(i); cudaDeviceReset(); //重置CUDA设备释放程序占用的资源 } } // system(&quot;pause&quot;); return 0; }","categories":[{"name":"资源","slug":"资源","permalink":"/https://calvinstudio.github.io/categories/资源/"}],"tags":[{"name":"OPENMP-CUDA","slug":"OPENMP-CUDA","permalink":"/https://calvinstudio.github.io/tags/OPENMP-CUDA/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"/https://calvinstudio.github.io/categories/资源/"}]},{"title":"Linux 操作命令大全","slug":"LINUX","date":"2019-12-10T06:45:00.000Z","updated":"2019-12-10T07:24:15.689Z","comments":true,"path":"2019/12/10/LINUX/","link":"","permalink":"/https://calvinstudio.github.io/2019/12/10/LINUX/","excerpt":"","text":"系统信息 arch 显示机器的处理器架构 (1) uname -m 显示机器的处理器架构 (2) uname -r 显示正在使用的内核版本 dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI) hdparm -i /dev/hda 罗列一个磁盘的架构特性 hdparm -tT /dev/sda 在磁盘上执行测试性读取操作 cat /proc/cpuinfo 显示 CPU info 的信息 cat /proc/interrupts 显示中断 cat /proc/meminfo 校验内存使用 cat /proc/swaps 显示哪些 swap 被使用 cat /proc/version 显示内核的版本 cat /proc/net/dev 显示网络适配器及统计 cat /proc/mounts 显示已加载的文件系统 lspci -tv 罗列 PCI 设备 lsusb -tv 显示 USB 设备 date 显示系统日期 cal 2007 显示 2007 年的日历表 date 041217002007.00 设置日期和时间 - 月日时分年 .秒 clock -w 将时间修改保存到 BIOS 文件和目录 cd /home 进入’/home’目录 cd .. 返回上一级目录 cd ../.. 返回上两级目录 cd 进入个人的主目录 cd ~user1 进入个人的主目录 cd - 返回上次所在的目录 pwd 显示工作路径 ls 查看目录中的文件 ls -F 查看目录中的文件2 ls -l 显示文件和目录的详细资料 ls -a 显示隐藏文件 ls *[0-9]* 显示包含数字的文件名和目录名 tree 显示文件和目录由根目录开始的树形结构 (1) lstree 显示文件和目录由根目录开始的树形结构 (2) mkdir dir1 创建一个名为 ‘dir1’ 的目录 ‘ mkdir dir1 dir2 同时创建两个目录 mkdir -p /tmp/dir1/dir2 创建一个目录树 rm -f file1 删除一个名为 ‘file1’ 的文件 rmdir dir1 删除一个名为 ‘dir1’ 的目录 rm -rf dir1 删除一个名为 ‘dir1’ 的目录并同时删除其内容 rm -rf dir1 dir2 同时删除两个目录及它们的内容 mv dir1 new_dir 重命名 /移动 一个目录 cp file1 file2 复制一个文件 cp dir/* 复制一个目录下的所有文件到当前工作目录 cp -a /tmp/dir1 复制一个目录到当前工作目录 cp -a dir1 dir2 复制一个目录 ln -s file1 lnk1 创建一个指向文件或目录的软链接 ln file1 lnk1 创建一个指向文件或目录的物理链接 打包和压缩文件 bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’ 的文件 bzip2 file1 压缩一个叫做 ‘file1’ 的文件 gunzip file1.gz 解压一个叫做 ‘file1.gz’ 的文件 gzip file1 压缩一个叫做 ‘file1’ 的文件 gzip -9 file1 最大程度压缩 rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包 rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’ rar x file1.rar 解压 rar 包 unrar x file1.rar 解压 rar 包 tar -cvf archive.tar file1 创建一个非压缩的 tarball tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件 tar -tf archive.tar 显示一个包中的内容 tar -xvf archive.tar 释放一个包 tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp 目录下 tar -cvfj archive.tar.bz2 dir1 创建一个 bzip2 格式的压缩包 tar -xvfj archive.tar.bz2 解压一个 bzip2 格式的压缩包 tar -cvfz archive.tar.gz dir1 创建一个 gzip 格式的压缩包 tar -xvfz archive.tar.gz 解压一个 gzip 格式的压缩包 zip file1.zip file1 创建一个 zip 格式的压缩包 zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个 zip 格式的压缩包5 unzip file1.zip 解压一个 zip 格式压缩包","categories":[{"name":"资源","slug":"资源","permalink":"/https://calvinstudio.github.io/categories/资源/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/https://calvinstudio.github.io/tags/Linux/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"/https://calvinstudio.github.io/categories/资源/"}]},{"title":"排序算法（下）","slug":"Sort copy","date":"2019-12-05T14:45:00.000Z","updated":"2019-12-05T05:28:36.741Z","comments":true,"path":"2019/12/05/Sort copy/","link":"","permalink":"/https://calvinstudio.github.io/2019/12/05/Sort copy/","excerpt":"","text":"超详细十大经典排序算法总结6、快速排序（Quick Sort）快速排序 的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 6.1 算法描述快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： 步骤1：从数列中挑出一个元素，称为 “基准”（ pivot ）； 步骤2：重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 步骤3：递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 6.2 动图演示 6.3 代码实现 /** * 快速排序方法 * @param array * @param start * @param end * @return */ public static int[] QuickSort(int[] array, int start, int end) { if (array.length &amp;lt; 1 || start &amp;lt; 0 || end &amp;gt;= array.length || start &amp;gt; end) return null; int smallIndex = partition(array, start, end); if (smallIndex &amp;gt; start) QuickSort(array, start, smallIndex - 1); if (smallIndex &amp;lt; end) QuickSort(array, smallIndex + 1, end); return array; } /** * 快速排序算法——partition * @param array * @param start * @param end * @return */ public static int partition(int[] array, int start, int end) { int pivot = (int) (start + Math.random() * (end - start + 1)); int smallIndex = start - 1; swap(array, pivot, end); for (int i = start; i &amp;lt;= end; i++) if (array[i] &amp;lt;= array[end]) { smallIndex++; if (i &amp;gt; smallIndex) swap(array, i, smallIndex); } return smallIndex; } /** * 交换数组内两个元素 * @param array * @param i * @param j */ public static void swap(int[] array, int i, int j) { int temp = array[i]; array[i] = array[j]; array[j] = temp; } int mpartition(int a[], int l, int r) { int pivot = a[l]; while (l&lt;r) { while (l&lt;r &amp;&amp; pivot&lt;=a[r]) r--; if (l&lt;r) a[l++]=a[r]; while (l&lt;r &amp;&amp; pivot&gt;a[l]) l++; if (l&lt;r) a[r--]=a[l]; } a[l]=pivot; return l; } void quick_sort (int a[], int l, int r) { if (l &lt; r) { int q = mpartition(a, l, r); msort(a, l, q-1); msort(a, q+1, r); } } 6.4 算法分析 最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(nlogn) 7、堆排序（Heap Sort）堆排序（Heapsort） 是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 7.1 算法描述 步骤1：将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； 步骤2：将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； 步骤3：由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 7.2 动图演示 7.3 代码实现注意：这里用到了完全二叉树的部分性质：详情见数据结构二叉树知识点 //声明全局变量，用于记录数组array的长度； static int len; /** * 堆排序算法 * * @param array * @return */ public static int[] HeapSort(int[] array) { len = array.length; if (len &amp;lt; 1) return array; //1.构建一个最大堆 buildMaxHeap(array); //2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆 while (len &amp;gt; 0) { swap(array, 0, len - 1); len--; adjustHeap(array, 0); } return array; } /** * 建立最大堆 * * @param array */ public static void buildMaxHeap(int[] array) { //从最后一个非叶子节点开始向上构造最大堆 //for循环这样写会更好一点：i的左子树和右子树分别2i+1和2(i+1) for (int i = (len/2- 1); i &amp;gt;= 0; i--) { adjustHeap(array, i); } } /** * 调整使之成为最大堆 * * @param array * @param i */ public static void adjustHeap(int[] array, int i) { int maxIndex = i; //如果有左子树，且左子树大于父节点，则将最大指针指向左子树 if (i * 2 &amp;lt; len &amp;amp;&amp;amp; array[i * 2] &amp;gt; array[maxIndex]) maxIndex = i * 2+1; //感谢网友矫正，之前是i*2 //如果有右子树，且右子树大于父节点，则将最大指针指向右子树 if (i * 2 + 1 &amp;lt; len &amp;amp;&amp;amp; array[i * 2 + 1] &amp;gt; array[maxIndex]) maxIndex = i * 2 + 2; //感谢网友矫正，之前是i*2+1 //如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。 if (maxIndex != i) { swap(array, maxIndex, i); adjustHeap(array, maxIndex); } } void heapAdjust(int a[], int i, int nLength) { int nChild; int nTemp; for (nTemp = a[i]; 2 * i + 1 &lt; nLength; i = nChild) { // 子结点的位置=2*（父结点位置）+ 1 nChild = 2 * i + 1; // 得到子结点中较大的结点 if ( nChild &lt; nLength-1 &amp;&amp; a[nChild + 1] &gt; a[nChild]) ++nChild; // 如果较大的子结点大于父结点那么把较大的子结点往上移动，替换它的父结点 if (nTemp &lt; a[nChild]) { a[i] = a[nChild]; a[nChild]= nTemp; } else // 否则退出循环 break; } } // 堆排序算法 void heap_sort(int a[],int length) { int tmp; // 调整序列的前半部分元素，调整完之后第一个元素是序列的最大的元素 //length/2-1是第一个非叶节点，此处&quot;/&quot;为整除 for (int i = length / 2 - 1; i &gt;= 0; --i) heapAdjust(a, i, length); // 从最后一个元素开始对序列进行调整，不断的缩小调整的范围直到第一个元素 for (int i = length - 1; i &gt; 0; --i) { // 把第一个元素和当前的最后一个元素交换， // 保证当前的最后一个位置的元素都是在现在的这个序列之中最大的 /// Swap(&amp;a[0], &amp;a[i]); tmp = a[i]; a[i] = a[0]; a[0] = tmp; // 不断缩小调整heap的范围，每一次调整完毕保证第一个元素是当前序列的最大值 heapAdjust(a, 0, i); } } #include&lt;iterator&gt; #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; const int BUCKET_NUM = 10; struct ListNode{ explicit ListNode(int i=0):mData(i),mNext(NULL){} ListNode* mNext; int mData; }; ListNode* insert(ListNode* head,int val){ ListNode dummyNode; ListNode *newNode = new ListNode(val); ListNode *pre,*curr; dummyNode.mNext = head; pre = &amp;dummyNode; curr = head; while(NULL!=curr &amp;&amp; curr-&gt;mData&lt;=val){ pre = curr; curr = curr-&gt;mNext; } newNode-&gt;mNext = curr; pre-&gt;mNext = newNode; return dummyNode.mNext; } ListNode* Merge(ListNode *head1,ListNode *head2){ ListNode dummyNode; ListNode *dummy = &amp;dummyNode; while(NULL!=head1 &amp;&amp; NULL!=head2){ if(head1-&gt;mData &lt;= head2-&gt;mData){ dummy-&gt;mNext = head1; head1 = head1-&gt;mNext; }else{ dummy-&gt;mNext = head2; head2 = head2-&gt;mNext; } dummy = dummy-&gt;mNext; } if(NULL!=head1) dummy-&gt;mNext = head1; if(NULL!=head2) dummy-&gt;mNext = head2; return dummyNode.mNext; } void BucketSort(int n,int arr[]){ vector&lt;ListNode*&gt; buckets(BUCKET_NUM,(ListNode*)(0)); for(int i=0;i&lt;n;++i){ int index = arr[i]/BUCKET_NUM; ListNode *head = buckets.at(index); buckets.at(index) = insert(head,arr[i]); } ListNode *head = buckets.at(0); for(int i=1;i&lt;BUCKET_NUM;++i){ head = Merge(head,buckets.at(i)); } for(int i=0;i&lt;n;++i){ arr[i] = head-&gt;mData; head = head-&gt;mNext; } } 7.4 算法分析 最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn) 8、计数排序（Counting Sort）计数排序 的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。计数排序(Counting sort) 是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。 8.1 算法描述 步骤1：找出待排序的数组中最大和最小的元素； 步骤2：统计数组中每个值为i的元素出现的次数，存入数组C的第i项； 步骤3：对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； 步骤4：反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 8.2 动图演示 8.3 代码实现 /** * 计数排序 * * @param array * @return */ public static int[] CountingSort(int[] array) { if (array.length == 0) return array; int bias, min = array[0], max = array[0]; for (int i = 1; i &amp;lt; array.length; i++) { if (array[i] &amp;gt; max) max = array[i]; if (array[i] &amp;lt; min) min = array[i]; } bias = 0 - min; int[] bucket = new int[max - min + 1]; Arrays.fill(bucket, 0); for (int i = 0; i &amp;lt; array.length; i++) { bucket[array[i] + bias]++; } int index = 0, i = 0; while (index &amp;lt; array.length) { if (bucket[i] != 0) { array[index] = i - bias; bucket[i]--; index++; } else i++; } return array; } void findArrMaxMin(int a[], int size, int *min, int *max) { if(size == 0) { return; } if(size == 1) { *min = *max = a[0]; return; } *min = a[0] &gt; a[1] ? a[1] : a[0]; *max = a[0] &lt;= a[1] ? a[1] : a[0]; int i, j; for(i = 2, j = 3; i &lt; size, j &lt; size; i += 2, j += 2) { int tempmax = a[i] &gt;= a[j] ? a[i] : a[j]; int tempmin = a[i] &lt; a[j] ? a[i] : a[j]; if(tempmax &gt; *max) *max = tempmax; if(tempmin &lt; *min) *min = tempmin; } //如果数组元素是奇数个，那么最后一个元素在分组的过程中没有包含其中， //这里单独比较 if(size % 2 != 0) { if(a[size -1] &gt; *max) *max = a[size - 1]; else if(a[size -1] &lt; *min) *min = a[size -1]; } } void count_sort(int a[], int b[], int n) { int max, min; findArrMaxMin(a, n, &amp;min, &amp;max); int numRange = max-min+1; int* counter = new int[numRange]; int i, j, k; for (k=0; k&lt;numRange; k++) counter[k]=0; for (i=0; i&lt;n; i++) counter[a[i]-min]++; for (k=1; k&lt;numRange; k++) counter[k] += counter[k-1]; for (j=n-1; j&gt;=0; j--) { int v = a[j]; int index = counter[v-min]-1; b[index]=v; counter[v-min]--; } } 8.4 算法分析 当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。 最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n+k) 9、桶排序（Bucket Sort）桶排序 是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排 9.1 算法描述 步骤1：人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize==5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）； 步骤2：遍历输入数据，并且把数据一个一个放到对应的桶里去； 步骤3：对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序； 步骤4：从不是空的桶里把排好序的数据拼接起来。 注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。 9.2 图片演示 9.3 代码实现 /** * 桶排序 * * @param array * @param bucketSize * @return */ public static ArrayList&amp;lt;Integer&amp;gt; BucketSort(ArrayList&amp;lt;Integer&amp;gt; array, int bucketSize) { if (array == null || array.size() &amp;lt; 2) return array; int max = array.get(0), min = array.get(0); // 找到最大值最小值 for (int i = 0; i &amp;lt; array.size(); i++) { if (array.get(i) &amp;gt; max) max = array.get(i); if (array.get(i) &amp;lt; min) min = array.get(i); } int bucketCount = (max - min) / bucketSize + 1; ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; bucketArr = new ArrayList&amp;lt;&amp;gt;(bucketCount); ArrayList&amp;lt;Integer&amp;gt; resultArr = new ArrayList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; bucketCount; i++) { bucketArr.add(new ArrayList&amp;lt;Integer&amp;gt;()); } for (int i = 0; i &amp;lt; array.size(); i++) { bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i)); } for (int i = 0; i &amp;lt; bucketCount; i++) { if (bucketSize == 1) { // 如果带排序数组中有重复数字时 for (int j = 0; j &amp;lt; bucketArr.get(i).size(); j++) resultArr.add(bucketArr.get(i).get(j)); } else { if (bucketCount == 1) bucketSize--; ArrayList&amp;lt;Integer&amp;gt; temp = BucketSort(bucketArr.get(i), bucketSize); for (int j = 0; j &amp;lt; temp.size(); j++) resultArr.add(temp.get(j)); } } return resultArr; } cpp 9.4 算法分析桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n2) 10、基数排序（Radix Sort）基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数； 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。 10.1 算法描述 步骤1：取得数组中的最大数，并取得位数； 步骤2：arr为原始数组，从最低位开始取每个位组成radix数组； 步骤3：对radix进行计数排序（利用计数排序适用于小范围数的特点）； 10.2 动图演示 10.3 代码实现 /** * 基数排序 * @param array * @return */ public static int[] RadixSort(int[] array) { if (array == null || array.length &amp;lt; 2) return array; // 1.先算出最大数的位数； int max = array[0]; for (int i = 1; i &amp;lt; array.length; i++) { max = Math.max(max, array[i]); } int maxDigit = 0; while (max != 0) { max /= 10; maxDigit++; } int mod = 10, div = 1; ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; bucketList = new ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt;(); for (int i = 0; i &amp;lt; 10; i++) bucketList.add(new ArrayList&amp;lt;Integer&amp;gt;()); for (int i = 0; i &amp;lt; maxDigit; i++, mod *= 10, div *= 10) { for (int j = 0; j &amp;lt; array.length; j++) { int num = (array[j] % mod) / div; bucketList.get(num).add(array[j]); } int index = 0; for (int j = 0; j &amp;lt; bucketList.size(); j++) { for (int k = 0; k &amp;lt; bucketList.get(j).size(); k++) array[index++] = bucketList.get(j).get(k); bucketList.get(j).clear(); } } return array; } int getNumInPos(int num,int pos) //获得某个数字的第pos位的值 { int temp = 1; for (int i = 0; i &lt; pos - 1; i++) temp *= 10; return (num / temp) % 10; } #define RADIX_10 10 //十个桶，表示每一位的十个数字 #define KEYNUM 5 //整数位数 void radix_sort(int* pDataArray, int iDataNum) { int *radixArrays[RADIX_10]; //分别为0~9的序列空间 for (int i = 0; i &lt; RADIX_10; i++) { radixArrays[i] = new int[iDataNum]; radixArrays[i][0] = 0; //index为0处记录这组数据的个数 } for (int pos = 1; pos &lt;= KEYNUM; pos++) //从个位开始到31位 { for (int i = 0; i &lt; iDataNum; i++) //分配过程 { int num = getNumInPos(pDataArray[i], pos); int index = ++radixArrays[num][0]; radixArrays[num][index] = pDataArray[i]; } for (int i = 0, j =0; i &lt; RADIX_10; i++) //写回到原数组中，复位radixArrays { for (int k = 1; k &lt;= radixArrays[i][0]; k++) pDataArray[j++] = radixArrays[i][k]; radixArrays[i][0] = 0; } } } 10.4 算法分析 最佳情况：T(n) = O(n * k) 最差情况：T(n) = O(n * k) 平均情况：T(n) = O(n * k) 10.5 基数排序有两种方法： MSD 从高位开始进行排序 LSD 从低位开始进行排序 基数排序 vs 计数排序 vs 桶排序 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序： 根据键值的每位数字来分配桶 计数排序： 每个桶只存储单一键值 桶排序： 每个桶存储一定范围的数值","categories":[{"name":"资源","slug":"资源","permalink":"/https://calvinstudio.github.io/categories/资源/"}],"tags":[{"name":"C++","slug":"C","permalink":"/https://calvinstudio.github.io/tags/C/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"/https://calvinstudio.github.io/categories/资源/"}]},{"title":"排序算法(上)","slug":"Sort","date":"2019-12-04T14:45:00.000Z","updated":"2019-12-05T02:03:15.299Z","comments":true,"path":"2019/12/04/Sort/","link":"","permalink":"/https://calvinstudio.github.io/2019/12/04/Sort/","excerpt":"","text":"超详细十大经典排序算法总结排序算法说明 0.1排序的定义 对一序列对象根据某个关键字进行排序。 0.2术语说明稳定 如果a原本在b前面，而a=b，排序之后a仍然在b的前面； 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 内排序：所有排序操作都在内存中完成； 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度 ：一个算法执行所耗费的时间。 空间复杂度 ：运行完一个程序所需内存的大小。 0.3 算法总结 图片名词解释： n: 数据规模 k: “桶”的个数 In-place: 占用常数内存，不占用额外内存- Out-place: 占用额外内存 0.5 算法分类 0.6 比较和非比较的区别 常见的—快速排序、归并排序、堆排序、冒泡排序—等属于比较排序。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。 在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。 比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。 计数排序、基数排序、桶排序则属于非比较排序 。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置 。 非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。 非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。 1、冒泡排序（Bubble Sort）冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 1.1 算法描述 步骤1: 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 步骤2: 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 步骤3: 针对所有的元素重复以上的步骤，除了最后一个；- 步骤4: 重复步骤1~3，直到排序完成。 1.2 动图演示 1.3 代码实现 * 冒泡排序 * * @param array * @return public static int[] bubbleSort(int[] array) { if (array.length == 0) return array; for (int i = 0; i &amp;lt; array.length; i++) for (int j = 0; j &amp;lt; array.length - 1 - i; j++) if (array[j + 1] &amp;lt; array[j]) { int temp = array[j + 1]; array[j + 1] = array[j]; array[j] = temp; } return array; } void bubble_sort (int a[], int n) { int i, j, lastSwap, tmp; for (j=n-1; j&gt;0; j=lastSwap) { lastSwap=0; //每一轮要初始化为0，防止某一轮未发生交换，lastSwap保留上一轮的值进入死循环 for (i=0; i&lt;j; i++) { if (a[i] &gt; a[i+1]) { tmp=a[i]; a[i]=a[i+1]; a[i+1]=tmp; //最后一次交换位置的坐标 lastSwap = i; } } } } 1.4 算法分析 最佳情况：T(n) = O(n) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(n2) 2、选择排序（Selection Sort）选择排序是表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。 选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 2.1 算法描述n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： 步骤1：初始状态：无序区为R[1…n]，有序区为空； 步骤2：第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1…i-1]和R(i…n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1…i]和R[i+1…n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； 步骤3：n-1趟结束，数组有序化了。 2.2 动图演示 2.3 代码实现 * 选择排序 * @param array * @return public static int[] selectionSort(int[] array) { if (array.length == 0) return array; for (int i = 0; i &amp;lt; array.length; i++) { int minIndex = i; for (int j = i; j &amp;lt; array.length; j++) { if (array[j] &amp;lt; array[minIndex]) //找到最小的数 minIndex = j; //将最小数的索引保存 } int temp = array[minIndex]; array[minIndex] = array[i]; array[i] = temp; } return array; } void selection_sort (int a[], int n) { int i,j,pos,tmp; for (i=0; i&lt;n-1; i++) { //寻找最小值的下标 for (pos=i, j=i+1; j&lt;n; j++) if (a[pos]&gt;a[j]) pos=j; if (pos != i) { tmp=a[i]; a[i]=a[pos]; a[pos]=tmp; } } } 2.4 算法分析 最佳情况：T(n) = O(n2) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(n2) 3、插入排序（Insertion Sort）插入排序（Insertion-Sort） 的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 3.1 算法描述 一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 步骤1: 从第一个元素开始，该元素可以认为已经被排序； 步骤2: 取出下一个元素，在已经排序的元素序列中从后向前扫描； 步骤3: 如果该元素（已排序）大于新元素，将该元素移到下一位置； 步骤4: 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 步骤5: 将新元素插入到该位置后； 步骤6: 重复步骤2~5。 3.2 动图演示 3.3 代码实现 * 插入排序 * @param array * @return public static int[] insertionSort(int[] array) { if (array.length == 0) return array; int current; for (int i = 0; i &amp;lt; array.length - 1; i++) { current = array[i + 1]; int preIndex = i; while (preIndex &amp;gt;= 0 &amp;amp;&amp;amp; current &amp;lt; array[preIndex]) { array[preIndex + 1] = array[preIndex]; preIndex--; } array[preIndex + 1] = current; } return array; } void insertion_sort (int a[], int n) { int i,j,v; for (i=1; i&lt;n; i++) { //如果第i个元素小于第j个，则第j个向后移动 for (v=a[i], j=i-1; j&gt;=0&amp;&amp;v&lt;a[j]; j--) a[j+1]=a[j]; a[j+1]=v; } } 3.4 算法分析 最佳情况：T(n) = O(n) 最坏情况：T(n) = O(n2) 平均情况：T(n) = O(n2) 4、希尔排序（Shell Sort）希尔排序是希尔（Donald Shell） 于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。 希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 4.1 算法描述我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： 步骤1：选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 步骤2：按增量序列个数k，对序列进行k 趟排序； 步骤3：每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 4.2 过程演示 4.3 代码实现 /** * 希尔排序 * * @param array * @return */ public static int[] ShellSort(int[] array) { int len = array.length; int temp, gap = len / 2; while (gap &amp;gt; 0) { for (int i = gap; i &amp;lt; len; i++) { temp = array[i]; int preIndex = i - gap; while (preIndex &amp;gt;= 0 &amp;amp;&amp;amp; array[preIndex] &amp;gt; temp) { array[preIndex + gap] = array[preIndex]; preIndex -= gap; } array[preIndex + gap] = temp; } gap /= 2; } return array; } void shell_sort(int a[], int n) { int d, i, j, temp; //d为增量 for(d = n/2;d &gt;= 1;d = d/2) //增量递减到1使完成排序 { for(i = d; i &lt; n;i++) //插入排序的一轮 { temp = a[i]; for(j = i - d;(j &gt;= 0) &amp;&amp; (a[j] &gt; temp);j = j-d) { a[j + d] = a[j]; } a[j + d] = temp; } } } 4.4 算法分析 最佳情况：T(n) = O(nlog2 n) 最坏情况：T(n) = O(nlog2 n) 平均情况：T(n) =O(nlog2n) 5、归并排序（Merge Sort）和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。 归并排序 是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 5.1 算法描述 步骤1：把长度为n的输入序列分成两个长度为n/2的子序列；- 步骤2：对这两个子序列分别采用归并排序； 步骤3：将两个排序好的子序列合并成一个最终的排序序列。 5.2 动图演示 5.3 代码实现 /** * 归并排序 * * @param array * @return */ public static int[] MergeSort(int[] array) { if (array.length &amp;lt; 2) return array; int mid = array.length / 2; int[] left = Arrays.copyOfRange(array, 0, mid); int[] right = Arrays.copyOfRange(array, mid, array.length); return merge(MergeSort(left), MergeSort(right)); } /** * 归并排序——将两段排序好的数组结合成一个排序数组 * * @param left * @param right * @return */ public static int[] merge(int[] left, int[] right) { int[] result = new int[left.length + right.length]; for (int index = 0, i = 0, j = 0; index &amp;lt; result.length; index++) { if (i &amp;gt;= left.length) result[index] = right[j++]; else if (j &amp;gt;= right.length) result[index] = left[i++]; else if (left[i] &amp;gt; right[j]) result[index] = right[j++]; else result[index] = left[i++]; } return result; } void mergearray(int a[], int first, int mid, int last, int temp[]) { int i = first, j = mid + 1; int m = mid, n = last; int k = 0; while (i &lt;= m &amp;&amp; j &lt;= n) { if (a[i] &lt;= a[j]) temp[k++] = a[i++]; else temp[k++] = a[j++]; } while (i &lt;= m) temp[k++] = a[i++]; while (j &lt;= n) temp[k++] = a[j++]; for (i = 0; i &lt; k; i++) a[first + i] = temp[i]; } void merge_sort(int a[], int first, int last, int temp[]) { if (first &lt; last) { int mid = (first + last) / 2; merge_sort(a, first, mid, temp); //左边有序 merge_sort(a, mid + 1, last, temp); //右边有序 mergearray(a, first, mid, last, temp); //再将二个有序数列合并 } } 5.4 算法分析 最佳情况：T(n) = O(n) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn)","categories":[{"name":"资源","slug":"资源","permalink":"/https://calvinstudio.github.io/categories/资源/"}],"tags":[{"name":"C++","slug":"C","permalink":"/https://calvinstudio.github.io/tags/C/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"/https://calvinstudio.github.io/categories/资源/"}]},{"title":"多维数组内存分配与释放","slug":"Array","date":"2019-12-01T14:45:00.000Z","updated":"2019-12-05T02:03:01.331Z","comments":true,"path":"2019/12/01/Array/","link":"","permalink":"/https://calvinstudio.github.io/2019/12/01/Array/","excerpt":"","text":"2D Arrayfloat **TwoArrayAlloc(int r, int c) // 分配二维内存数组// { float **p; p = (float **)calloc(r, sizeof(float *)); //第一维 for (int i = 0; i&lt;r; i++) { p[i] = (float *)calloc(c, sizeof(float *)); //第二维 } return(p); } void TwoArrayFree(float **x) { free(x[0]); free(x); } float Min(float **p, int nx, int nz) //二维数组中最小值// { float min; int i, j; min = p[0][0]; for (i = 0; i&lt;nz; i++) { for (j = 0; j&lt;nx; j++) { if (min&gt;p[i][j]) { min = p[i][j]; } } } return min; } float Max(float **p, int nx, int nz) //二维数组中最大值// { float max; int i, j; max = p[0][0]; for (i = 0; i&lt;nz; i++) { for (j = 0; j&lt;nx; j++) { if (max&lt;p[i][j]) { max = p[i][j]; } } } return max; } 3D Arrayfloat ***ThreeArrayAlloc(int l, int m, int n) // 分配三维内存数组// { //int l,m,n; //三维的长度，假设已知 float ***p; int i, j; p = (float ***)calloc(l, sizeof(float **)); //第一维 for (i = 0; i&lt;l; i++) { p[i] = (float **)calloc(m, sizeof(float *)); //第二维 for (j = 0; j&lt;m; j++) p[i][j] = (float *)calloc(n, sizeof(float)); //第三维 } return(p); } void ThreeArrayFree(float ***p) { free(p[0][0]); //第三维 free(p[0]); //第二维 free(p); //第一维 } float Min(float ***p, int nx, int ny, int nz) { float min; min = p[0][0][0]; for (int i = 0; i&lt;nz; i++) for (int j = 0; j&lt;ny; j++) for (int k = 0; k&lt;nx; k++) { if (min&gt;p[i][j][k]) { min = p[i][j][k]; } } return min; } float Max(float ***p, int nx, int ny, int nz) { float max; max = p[0][0][0]; for (int i = 0; i&lt;nz; i++) for (int j = 0; j&lt;ny; j++) for (int k = 0; k&lt;nx; k++) { if (max&lt;p[i][j][k]) { max = p[i][j][k]; } } return max; } sortvoid sort(float *array, int n) //一维数组排序算法// { int i, j, k; float t; for (i = 0; i&lt;n - 1; i++) { k = i; for (j = i + 1; j&lt;n; j++) if (array[j]&lt;array[k]) k = j; t = array[k]; array[k] = array[i]; array[i] = t; } }","categories":[{"name":"资源","slug":"资源","permalink":"/https://calvinstudio.github.io/categories/资源/"}],"tags":[{"name":"C++","slug":"C","permalink":"/https://calvinstudio.github.io/tags/C/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"/https://calvinstudio.github.io/categories/资源/"}]},{"title":"网站推荐","slug":"Web","date":"2019-11-07T14:45:00.000Z","updated":"2019-12-05T01:55:19.410Z","comments":true,"path":"2019/11/07/Web/","link":"","permalink":"/https://calvinstudio.github.io/2019/11/07/Web/","excerpt":"","text":"This is a collection of several tool sites in my collection: 格式转换迅捷PDF转换器 源码下载MATLAB File Exchange源码搜搜 办公资源OfficePLUS 图片VCG视觉中国 网盘下载PanSoso 文献下载SCI-HUB SdsdsB 其他算法动态演示","categories":[{"name":"资源","slug":"资源","permalink":"/https://calvinstudio.github.io/categories/资源/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"/https://calvinstudio.github.io/tags/Tools/"},{"name":"网站","slug":"网站","permalink":"/https://calvinstudio.github.io/tags/网站/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"/https://calvinstudio.github.io/categories/资源/"}]}]}